---
title: "Pteropod biomarker analysis"
author: ""
output: 
  html_document:
    code_folding: hide
    css: kable.css
self_contained: yes
runtime: shiny
---

```{r, message = F, warning = F}
library(knitr)
opts_chunk$set(warning = FALSE, message = FALSE, dev.args = list(bg = 'transparent'), eval = T)

library(tidyverse)
library(vegan)
library(ggord)
library(scales)
library(effects)
library(shiny)
library(plotly)

source("R/funcs.R")

data(envdat)
data(ptedat)

envchr <- c('pCO2', 'pH', 'CO3', 'Ara', 'O2', 'Temp', 'Fluor')
ptechr <- c('CAT', 'GR', 'GSHonGSSG', 'GST', 'LPX', 'ORAC', 'SOD', 'ORACvLPX')
```

## Methods

The response of pteropods to multiple stressors at the cellular, physiological, and population levels were evaluated using correlation analysis, multiple linear regression, and multivariate analysis. The general approach was to identify relationships among variables as potentially additive, synergistic, and antagonistic by evaluating pairwise effects of stressors on each response measure. Pearson correlations of environmental parameters (OA parameters, temperature, and chlorophyll) with cellular, physiological, and population response were first evaluated to identify potential associations with individual variables. Correlations between cellular and physiological responses were also evaluated to identify links between the two levels of biological organization. Non-continuous or skewed variables were transformed to better satisfy assumptions of the parametric tests (e.g., abundances were logarithmically transformed, proportions were arcsine transformed). All analyses were performed with the R statistical programming language (R Core Team 2017).

Linear models were developed for every pairwise combination of environmental variables to evaluate additive and interactive effects on stressor response. Each model included separate terms for individual variables and a third term for the interaction of the pair. Evidence for additive effects were based solely on the magnitude of the estimated parameter for each variable, whereas synergistic or antagonistic effects were evaluated from the estimated parameter for the interaction. A positive interaction was evidence of a synergistic effect and a negative interaction was evidence of an antagonistic effect. Results of the linear models were further evaluated using effects plots to characterize the relationship of a pteropod response measure to continuous values for one stressor given two different values for the second stressor (constant at the minimum and maximum observed values). Thresholds for synergistic or antagonistic effects between two variables were identified from the effects plots as the intersection between the two fitted lines.

Variance Inflation Factors (VIF) were quantified for all pairwise combinations of environmental variables used in the regression analysis to evaluate collinearity, such that:

VIFj = 1 /( 1 − R2j) 		(1)

where VIF is the reciprocal of the unexplained variance (1 − R2) of the linear regression of variable j against all other explanatory variables (Zuur et al., 2007). Although there are no specific VIF thresholds beyond which a variable is considered overly collinear, values less than 50 are generally considered adequate (Zuur et al. 2007). Comparisons of variables indicated that all VIF were below this threshold, except combinations of CO3/Aragonite (70.6), pCO2/CO3 (51.4), and ph/pCO2 (79.2).

Finally, multivariate comparisons between the cellular response measures and environmental variables were assessed using redundancy analysis (RDA) to jointly characterize relationships between all sampling stations. This analysis is conceptually similar to principal components analysis with an additional constraint on the environmental matrix, where the relationships are further partitioned based on covariance among response measures at each site in addition to the covariance between environmental variables. The final triplot (two biplots of environmental and response matrices) can be used to evaluate which environmental variables are correlated, as well as their relationships to the cellular response measures at each site. The environmental and response matrices were standardized to range from 0-1 prior to RDA. The vegan package for R was used for standardization and RDA (Oksanen et al. 2017). 

Oksanen, J., Guillaume Blanchet, F.,  Friendly, M., Kindt, R.,  Legendre, P., McGlinn, D., Minchin, P.R., O'Hara, R.B., Simpson, G.L., Solymos, P., Henry, M., Stevens, H., Szoecs, E., Wagner, H. 2017. vegan: Community Ecology Package. R package version 2.4-5. https://CRAN.R-project.org/package=vegan

R Core Team (2017). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.  

Zuur, A.F., Ieno, E.N., Smith, G.M. 2007. Analysing Ecological DAta. Springer, New York, NY. 
MOntgomery, D.C., Peck, E.A. 1992. Introduction to Linear Regression Analysis. Wiley, New York, NY. 

Pairs plot
```{r, fig.height = 8, fig.width = 8}
dat <- ptedat %>% 
  select(one_of('CTD', ptechr)) %>% 
  na.omit %>% 
  inner_join(envdat, by = 'CTD') %>% 
  select(one_of(c('CTD', envchr, ptechr)))
 
pairs(dat[, -1], gap = 0, cex = 1, col = 'grey')
```

RDA triplot of biomarkers and environmental data
```{r, fig.height = 4, fig.width = 5, eval = T}
dat_frm <- dat %>% 
  data.frame %>% 
  remove_rownames %>% 
  column_to_rownames('CTD')

env <- select(dat_frm, one_of(envchr)) %>% 
  decostand(method = 'range')
pte <- select(dat_frm, one_of(ptechr)) %>% 
  decostand(method = 'range')

mod <- rda(pte, env)
ggord(mod, ptslab = T, parse = T)
```

# {.tabset}

```{r}
# all correlations
crs <- crossing(var1 = names(dat_frm), var2 = names(dat_frm)) %>% 
  filter(var1 != var2) %>% 
  rownames_to_column() %>% 
  group_by(rowname) %>% 
  nest %>% 
  mutate(
    crs = map(data, function(x){
      
      # variables
      vr1 <- dat_frm[[x$var1]]
      vr2 <- dat_frm[[x$var2]]
      
      # pearson
      pr_ts <- cor.test(vr1, vr2, method = 'pearson')
      pr_cr <- round(pr_ts$estimate, 2)
      pr_pv <- p_ast(pr_ts$p.value)
      pr <- paste(pr_cr, pr_pv)
      
      # spearman
      sp_ts <- suppressWarnings(cor.test(vr1, vr2, method = 'spearman'))
      sp_cr <- round(sp_ts$estimate, 2)
      sp_pv <- p_ast(sp_ts$p.value)
      sp <- paste(sp_cr, sp_pv)

      out <- data.frame(pr = pr, sp = sp, stringsAsFactors = F)
      return(out)
      
    })
  ) %>% 
  unnest %>% 
  select(-rowname)

sp_cr <- crs %>% 
  select(var1, var2, sp) %>% 
  spread(var2, sp) %>% 
  data.frame(stringsAsFactors = F) %>% 
  remove_rownames %>% 
  column_to_rownames('var1') 

pr_cr <- crs %>% 
  select(var1, var2, pr) %>% 
  spread(var2, pr) %>% 
  data.frame(stringsAsFactors = F) %>% 
  remove_rownames %>% 
  column_to_rownames('var1') 
```

## Spearman correlations
<div class="verysmall">

```{r}
knitr::kable(sp_cr, caption = 'Spearman rank correlations')
```

</div>

```{r spheat, fig.height = 5, fig.width = 10}
spplo <- crs %>% 
  select(-pr) %>% 
  separate(sp, c('cor', 'sig'), sep = ' ') %>% 
  mutate(
    cor = as.numeric(cor), 
    var1 = factor(var1, levels = rev(unique(.$var1)))
  )

pbase <- theme(
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(), 
  axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 8), 
  axis.text.y = element_text(size = 8),
  legend.position = 'top', 
  plot.margin = grid::unit(c(2, 2, 2, 2), 'pt'), 
  strip.background = element_blank(), 
  strip.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5), 
  panel.background = element_rect(fill = 'black')
  ) 

p <- ggplot(spplo, aes(y = var1, x = var2, fill = cor)) + 
  geom_tile(colour = 'black') + 
  pbase +
  scale_y_discrete('', expand = c(0, 0)) + 
  scale_x_discrete('', expand = c(0, 0)) +
  scale_fill_gradient2('Correlation', low = muted("green"), mid = "white", high = muted("blue"), midpoint = 0) +
  guides(fill = guide_colourbar(barheight = 0.5, barwidth = 5, label.theme = element_text(size = 6, angle = 0)))
p
```

## Pearson correlations
<div class="verysmall">

```{r}
knitr::kable(pr_cr, caption = 'Pearson correlations')
```

</div>

```{r prheat, fig.height = 5, fig.width = 10}
prplo <- crs %>% 
  select(-sp) %>% 
  separate(pr, c('cor', 'sig'), sep = ' ') %>% 
  mutate(
    cor = as.numeric(cor), 
    var1 = factor(var1, levels = rev(unique(.$var1)))
  )

pbase <- theme(
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(), 
  axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 8), 
  axis.text.y = element_text(size = 8),
  legend.position = 'top', 
  plot.margin = grid::unit(c(2, 2, 2, 2), 'pt'), 
  strip.background = element_blank(), 
  strip.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5), 
  panel.background = element_rect(fill = 'black')
  ) 

p <- ggplot(prplo, aes(y = var1, x = var2, fill = cor)) + 
  geom_tile(colour = 'black') + 
  pbase +
  scale_y_discrete('', expand = c(0, 0)) + 
  scale_x_discrete('', expand = c(0, 0)) +
  scale_fill_gradient2('Correlation', low = muted("green"), mid = "white", high = muted("blue"), midpoint = 0) +
  guides(fill = guide_colourbar(barheight = 0.5, barwidth = 5, label.theme = element_text(size = 6, angle = 0)))
p
```

# Pairwise VIF among environmental variables

```{r}
vifv <- crossing(var1 = envchr, var2 = envchr) %>% 
  filter(var1 != var2) %>% 
  rownames_to_column() %>% 
  group_by(rowname) %>% 
  nest %>% 
  mutate(
    vifv = map(data, function(x){
      
    vr1 <- x[['var1']]
    vr2 <- x[['var2']]
    frm <- formula(paste(vr1, '~', vr2))
    mod <- lm(frm, dat_frm)
    rsq <- mod %>% 
      summary %>% 
      .$r.squared
    vif <- 1 / (1 - rsq)
    
    return(vif)
    
    })
  ) %>% 
  unnest %>% 
  select(-rowname) %>% 
  mutate(vifv = round(vifv, 2)) %>% 
  spread(var2, vifv) %>% 
  data.frame(stringsAsFactors = F) %>% 
  remove_rownames %>% 
  column_to_rownames('var1') 
```

<div class="verysmall">

```{r}
knitr::kable(vifv, caption = 'VIF')
```

</div>

# {.tabset}

Pairwise models with interactions for each biomarker
```{r}
# variables to model, chr strings only
env_cmb <- names(env) %>% 
  combn(2) %>% 
  t %>% 
  data.frame(stringsAsFactors = F) %>%
  crossing(names(pte), .) %>% 
  t %>% 
  data.frame(stringsAsFactors = F) %>% 
  as.list

# models
mod_all <- env_cmb %>%
  map(function(x){
    
    # formula
    frm <- paste(x[1], '~', x[2], '*', x[3]) %>% 
      as.formula
    
    # model only
    lm(frm, data = dat_frm)
    
  }) %>% 
  enframe('Model', 'Modobj') %>% 
  mutate(
    Model = gsub('^X', 'mod', Model), 
    data = map(Modobj, function(x){
      
      # response
      yvar <- all.vars(formula(x))[1]
     
      # rsq
      rsq <- summary(x) %>% 
        .$r.squared
      
      # coeff summary
      out <- x %>% 
        summary %>% 
        .$coefficients %>% 
        .[-1, c(1, 4)] %>% 
        data.frame %>% 
        rownames_to_column('env_lab') %>% 
        mutate(
          pte_lab = yvar,
          Rsq = round(rsq, 2),
          Est = round(Estimate, 2), 
          Pvl = p_ast(Pr...t..)
        ) %>% 
        select(pte_lab, env_lab, Rsq, Est, Pvl)
    
    return(out)
      
    })
  ) 
mods <- mod_all %>% 
  unnest(data)

```

```{r}
selectInput("mod", "Choose model:", paste0('mod', seq(1:nrow(mods))))

md <- reactive({

  md <- filter(mod_all, Model %in% input$mod) %>% 
  .$Modobj %>% 
  .[[1]]
  
  return(md)
  
})

levs1 <- reactive({
  
  levs1 <- quantile(md()$model[, 2],  c(0, 1)) %>% 
    list
  names(levs1) <- names(md()$model)[2]
  return(levs1)
  
})


levs2 <- reactive({
  
  levs2 <- quantile(md()$model[, 3], c(0, 1)) %>% 
    list
  names(levs2) <- names(md()$model)[3]
  return(levs2)
  
})

trm <- reactive({
  
  md() %>% coefficients %>% names %>% .[4]

})

prd_vl <- reactive({
  
  x <- md()$model %>% 
    .[, -1] %>% 
    data.frame %>% 
    as.list %>% 
    map(range) %>%
    map(function(x) seq(x[1], x[2], length = 100))
  
  nms <- names(x) 
  x <- crossing(x[[1]], x[[2]])
  names(x) <- nms
  
  prd_vl <- predict(md(), newdata = x) %>% 
    data.frame(., x)
  names(prd_vl)[1] <- all.vars(formula(md()))[1]

  return(prd_vl)
  
})

renderPrint({summary(md())})

renderPlot({
  toplo <- md()$model %>% 
    gather('var', 'val', -1)

  ggplot(toplo, aes_string(x='val', y=names(toplo)[1])) +
    geom_point() + 
    facet_wrap(~var, ncol = 2, scales = 'free_x') + 
    theme_bw(base_family = 'serif') + 
    geom_smooth(method = 'lm') + 
    theme(axis.title.x = element_blank())

}, height = 300, width = 600)

renderPlot({
  plot(effect(trm(), md(), xlevels = levs1()), multiline = T)
}, height = 300, width = 600)

renderPlot({
  plot(effect(trm(), md(), xlevels = levs2()), multiline = T)
}, height = 300, width = 600)

renderPlot({
  
  pbase <- theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10), 
    axis.text.y = element_text(size = 10),
    legend.position = 'top', 
    plot.margin = grid::unit(c(2, 2, 2, 2), 'pt'), 
    strip.background = element_blank(), 
    strip.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5)
  ) 

  p <- ggplot(prd_vl(), aes_string(y = names(prd_vl())[2], x = names(prd_vl())[3], fill = names(prd_vl())[1])) + 
    geom_tile(colour = 'black') + 
    theme_bw(base_family = 'serif') +
    pbase +
    scale_y_continuous(expand = c(0, 0)) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_fill_distiller(palette = 'Spectral') +
    guides(fill = guide_colourbar(barheight = 0.5, barwidth = 15, label.theme = element_text(size = 12, angle = 0)))
  p
}, height = 700, width = 700)

renderPlotly({
  
  dat <- prd_vl() %>% 
    spread_(key_col = names(.)[2], value_col = names(.)[1]) %>% 
    .[,-1] %>% 
    as.matrix
    
  scene <- list(
    aspectmode = 'manual', 
    aspectratio = list(x = 1, y = 1, z = 0.5), 
    xaxis = list(title = names(prd_vl()[3])),
    yaxis = list(title = names(prd_vl()[2])),
    zaxis = list(title = names(prd_vl()[1]))
    )
  
  p <- plot_ly(z = ~dat) %>% add_surface(colors = rev(RColorBrewer::brewer.pal(11, 'Spectral'))) %>% 
    layout(scene = scene)
  p

})
```

## CAT
```{r}
knitr::kable(filter(mods, pte_lab %in% 'CAT'), caption = 'CAT')
```

## GR
```{r}
knitr::kable(filter(mods, pte_lab %in% 'GR'), caption = 'GR')
```

## GSHonGSSG
```{r}
knitr::kable(filter(mods, pte_lab %in% 'GSHonGSSG'), caption = 'GSHonGSSG')
```

## GST
```{r}
knitr::kable(filter(mods, pte_lab %in% 'GST'), caption = 'GST')
```

## LPX
```{r}
knitr::kable(filter(mods, pte_lab %in% 'LPX'), caption = 'LPX')
```

## ORAC
```{r}
knitr::kable(filter(mods, pte_lab %in% 'ORAC'), caption = 'ORAC')
```

## SOD
```{r}
knitr::kable(filter(mods, pte_lab %in% 'SOD'), caption = 'SOD')
```

## ORACvLPX
```{r}
knitr::kable(filter(mods, pte_lab %in% 'ORACvLPX'), caption = 'ORACvLPX')
```
